snippet bp
	require "pry"; binding.pry
snippet case
	case ${1:object}
	when ${2:condition}
	${3}
snippet when
	when ${1:condition}
		${2}
snippet def
	def ${1}
		${2}
	end
snippet defs
	def self.$1
		$2
	end
snippet defni
	def ${1:name}${2:(${3:args})}
		fail(NotImplementedError.new)
	end
snippet defi
	def initialize(${1})
		${2}
	end
snippet memo
	def ${1}
		@$1 ||= ${2}
	end
snippet def?
	def ${1:name}?
		${2}
	end
snippet ?
	${1} ? ${2} : ${3}
snippet if
	if ${1}
		${2}
	end
snippet ife
	if ${1}
		${2}
	else
		${3}
	end
snippet elsif
	elsif ${1}
		${2}
snippet unless
	unless ${1}
		${2}
	end
snippet while
	while ${1:condition}
		${2}
	end
snippet gd
	return unless ${1}
snippet mod module .. end
	module ${1}
		${0}
	end
snippet cla class .. end
	class ${1}
		${0}
	end
snippet r
	attr_reader :${1}
snippet w
	attr_writer :${1}
snippet rw
	attr_accessor :${1}
snippet tim "time" w
	times { |${1:n}| ${2} }
snippet upt "upto" w
	upto(${1:1.0/0.0}) { |${2:n}| ${3} }
snippet ea "each" w
	each { |${1:e}| ${2} }
snippet map "map" w
	map { |${1:e}| ${2} }
snippet sor "sort" w
	sort { |a, b| ${1} }
snippet sorb "sort_by" w
	sort_by { |${1:e}| ${2} }
snippet ran "sort_by rand" w
	sort_by { rand }
snippet all "all?" w
	all? { |${1:e}| ${2} }
snippet any "any?" w
	any? { |${1:e}| ${2} }
snippet sub
	subject { $1 }
snippet s "subject" w
	subject
snippet sel "select" w
	select { |${1:e}| ${2} }
snippet lam "lambda" w
	lambda { |${1:args}| ${2} }
snippet do
	do |${1:variable}|
		${2}
	end
snippet : "hash" w
	${1:key}: ${2:'value'}${3}
snippet h "string hash" w
	'${1:key}' => ${2:'value'}${3}
snippet ed "each block" w
	${1:arr}.each do |${2:e}|
		${3}
	end
# For rspec
snippet stubnew
	allow(${1}).to receive(:new).with(${2}).and_return(${3})
snippet stub
	allow(${1}).to receive(:${2}).and_return(${3})
snippet stubany
	allow_any_instance_of(${1}).to receive(:${2}).and_return(${3})
snippet expect
	expect(${1}).to have_received(:${2}).and_return(${3})
snippet expectany
	expect_any_instance_of(${1}).to receive(:${2}).and_return(${3})
snippet de
	describe '${1}' do
		${2}
	end
snippet descit
	describe '$1' do
		subject { instance.${1} }
		it 'works' do
			subject
		end
	end
snippet let
	let(:${1}) { ${2} }
snippet subject
	subject(:${1}) { ${2} }
snippet it
	it '${1}' do
		${2}
	end
snippet con
	context '${1}' do
		${2}
	end
snippet bed
	before do
		${1}
	end
snippet spec
	require 'rails_helper'
	describe ${1} do
		${2}
	end
snippet rspec
	require 'rails_helper'
	describe ${1} do
		describe '${2:docstring}' do
			it 'works' do
				${3}
			end
		end
	end
snippet dc "described_class" w
	described_class
snippet puts
	puts "\n\n************ #{ ${1} } **************\n\n"
snippet px
	puts "xxxxxxxxxxxxxx"
snippet ex
	expect(subject).to ${0}
snippet tz "timezone" w
	Time.zone.now
snippet tc "Time.current" w
	Time.current
snippet bod "Time.current.beginning_of_day" w
	Time.current.beginning_of_day
snippet eod "Time.current.end_of_day" w
	Time.current.end_of_day
snippet boh "Time.current.beginning_of_hour" w
	Time.current.beginning_of_hour
snippet eoh "Time.current.end_of_hour" w
	Time.current.end_of_hour
snippet ->
	-> { ${0} }
snippet ->a
	->(${1:args}) { ${0} }
snippet iexp
	it { expect(subject).${1} ${2} }
snippet iexpb
	it { expect { subject }.${1} ${2} }
snippet isexp
	it { is_expected.to eq ${0} }
snippet exe
	expect(subject).to eq ${1}
snippet exp
	expect(subject).to be_present
snippet exs
	expect(subject.size).to eq ${0}
snippet exs2
	expect(subject.status).to eq 200
snippet fc "fixture create"
	create(:${1})
snippet fcl "fixture create_list"
	create_list(:${1:object}, ${2:number})
snippet bs "fixture build_stubbed"
	build_stubbed(:${1})
snippet sb "subject.body" w
	subject.body
snippet ss "subject.status" w
	subject.status
snippet ba
	before_action :${0:method}
snippet bt
	belongs_to :${0:association}
snippet btp
	belongs_to :${1:association}, polymorphic: true
snippet crw
	cattr_accessor :${0:attr_names}
snippet habtm
	has_and_belongs_to_many :${1:object}, join_table: '${2:table_name}', foreign_key: '${3}_id'
snippet hm
	has_many :${0:object}
snippet hmd
	has_many :${1:other}s, class_name: '${2:$1}', foreign_key: '${3:$1}_id', dependent: :destroy
snippet hmt
	has_many :${1:object}, through: :${0:object}
snippet ho
	has_one :${0:object}
snippet hod
	has_one :${1:object}, dependent: :${0:destroy}
snippet i18
	I18n.t('${1:type.key}')
snippet ist
	<%= image_submit_tag('${1:agree.png}', id: '${2:id}'${0}) %>
snippet log
	Rails.logger.${1:debug} ${0}
snippet log2
	RAILS_DEFAULT_LOGGER.${1:debug} ${0}
snippet logd
	Rails.logger.debug '${1:message}'
snippet loge
	Rails.logger.error '${1:message}'
snippet logf
	Rails.logger.fatal '${1:message}'
snippet logi
	Rails.logger.info '${1:message}'
snippet logw
	Rails.logger.warn '${1:message}'
# Model validation
snippet vn
	validates :${0:attribute}, numericality: true
snippet vp
	validates :${0:attribute}, presence: true
snippet vu
	validates :${0:attribute}, uniqueness: true
###############################
#   model callback snippets   #
###############################
# before callback
snippet mbv
	before_validation :${0:method}
snippet mbc
	before_create :${0:method}
snippet mbu
	before_update :${0:method}
snippet mbs
	before_save :${0:method}
snippet mbd
	before_destroy :${0:method}
snippet mp "map attribute" w
	map(&:${0:id})
snippet oa "order" w
	order('${0:field}')
snippet od "order desc" w
	order('${0:field} DESC')
snippet pa "params" w
	params[:${1:id}]
snippet op "options" w
	options[:${1:id}]
snippet ra
	render action: '${0:action}'
snippet ral
	render action: '${1:action}', layout: '${0:layoutname}'
snippet re
	redirect_to action: :${0:action}
snippet sc
	scope :${1:name}, -> { where(${2:field}: ${0:value}) }
snippet sl
	scope :${1:name}, lambda do |${2:value}|
		where('${3:field = ?}', ${0:value})
	end
###########################
#   migrations snippets   #
###########################
snippet mac
	add_column :${1:table_name}, :${2:column_name}, :${0:data_type}
snippet mai
	add_index :${1:table_name}, :${0:column_name}
snippet mrc
	remove_column :${1:table_name}, :${0:column_name}
snippet mrnc
	rename_column :${1:table_name}, :${2:old_column_name}, :${0:new_column_name}
snippet mcc
	change_column :${1:table}, :${2:column}, :${0:type}
snippet mnc
	t.${1:string} :${2:title}${3:, null: false}
snippet mct
	create_table :${1:table_name} do |t|
		${0}
	end
snippet trc
	t.remove :${0:column}
snippet tre
	t.rename :${1:old_column_name}, :${2:new_column_name}
	${0}
snippet tref
	t.references :${0:model}
snippet tcb
	t.boolean :${1:title}
	${0}
snippet tcbi
	t.binary :${1:title}, limit: ${2:2}.megabytes
	${0}
snippet tcd
	t.decimal :${1:title}, precision: ${2:10}, scale: ${3:2}
	${0}
snippet tcda
	t.date :${1:title}
	${0}
snippet tcdt
	t.datetime :${1:title}
	${0}
snippet tcf
	t.float :${1:title}
	${0}
snippet tch
	t.change :${1:name}, :${2:string}, ${3:limit}: ${4:80}
	${0}
snippet tci
	t.integer :${1:title}
	${0}
snippet tcl
	t.integer :lock_version, null: false, default: 0
	${0}
snippet tcr
	t.references :${1:taggable}, polymorphic: { default: '${2:Photo}' }
	${0}
snippet tcs
	t.string :${1:title}
	${0}
snippet tct
	t.text :${1:title}
	${0}
snippet tcti
	t.time :${1:title}
	${0}
snippet tcts
	t.timestamp :${1:title}
	${0}
snippet tctss
	t.timestamps
	${0}
snippet whe
	${1:Model}.where(${2:attr}: ${3:value})
snippet fi
	${1:Model}.find_by(${2:attr}: ${3:value})
snippet rh
	require 'rails_helper'
	describe ${1:ClassName} do
		describe '${2:docstring}' do
			it '$3' do
				$4
			end
		end
	end
