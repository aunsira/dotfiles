snippet bp "binding.pry"
require "pry"; binding.pry
endsnippet

# #!/usr/bin/ruby
snippet #! "#!/usr/bin/ruby"
#!/usr/bin/ruby
endsnippet

snippet req
require "${1}"${2}
endsnippet

snippet case
case ${1:object}
when ${2:condition}
${3}
endsnippet

snippet when
when ${1:condition}
	${2}
endsnippet

snippet def
def ${1:method_name}
	${2}
end
endsnippet

snippet defni
def ${1:name}${2:(${3:args})}
	fail(NotImplementedError.new)
end
endsnippet

snippet defi
def initialize(${1})
	${2}
end
endsnippet

snippet memo
def ${1:name}
	@$1 ||= ${2:value}
end
endsnippet

snippet deft
def test_${1:case_name}
	${2}
endsnippet

snippet ?
${1:condition} ? ${2:true} : ${3:false}
endsnippet

snippet if
if ${1:condition}
	${2}
end
endsnippet

snippet ife
if ${1:condition}
	${2}
else
	${3}
end
endsnippet

snippet elsif
elsif ${1:condition}
	${2}
endsnippet

snippet unless
unless ${1:condition}
	${2}
end
endsnippet

snippet while
while ${1:condition}
	${2}
end
endsnippet

snippet until
until ${1:condition}
	${2}
end
endsnippet

snippet gd "guard clause"
return unless ${1}
endsnippet

snippet module "module .. end"
module `!p
def ClassName(path):
	return re.sub(r'[_]', '', path.title())
snip.rv = ClassName(snip.basename)
`
	${1}
end
endsnippet

snippet cla "class .. end"
class `!p
def ClassName(path):
	return re.sub(r'[_]', '', path.title())
snip.rv = ClassName(snip.basename)
`
	${1}
end
endsnippet

snippet cla "class .. initialize .. end"
class `!p
def ClassName(path):
	return re.sub(r'[_]', '', path.title())
snip.rv = ClassName(snip.basename)
`
	def initialize(${1:args})
		${3}
	end
end
endsnippet

snippet new "Class.new"
${1:Class}.new(${2:args})
endsnippet

# attr_reader
snippet r
attr_reader :${1:attr_names}
endsnippet

# attr_writer
snippet w
attr_writer :${1:attr_names}
endsnippet

# attr_accessor
snippet rw
attr_accessor :${1:attr_names}
endsnippet

snippet tim "time" w
times { |${1:n}| ${2} }
endsnippet

snippet upt "upto" w
upto(${1:1.0/0.0}) { |${2:n}| ${3} }
endsnippet

snippet loo
loop { ${1} }
endsnippet

snippet ea "each" w
each { |${1:e}| ${2} }
endsnippet

snippet eab "each_byte" w
each_byte { |${1:byte}| ${2} }
endsnippet

snippet eac- "each_char { |chr| .. }" w
each_char { |${1:chr}| ${2} }
endsnippet

snippet eac- "each_cons(..) { |group| .. }" w
each_cons(${1:2}) { |${2:group}| ${3} }
endsnippet

snippet eai "each_index" w
each_index { |${1:i}| ${2} }
endsnippet

snippet eak "each_with_key" w
each_key { |${1:key}| ${2} }
endsnippet

snippet eal "each_line" w
each_line { |${1:line}| ${2} }
endsnippet

snippet eap "each_pair" w
each_pair { |${1:name}, ${2:val}| ${3} }
endsnippet

snippet eas- "each_slice" w
each_slice(${1:2}) { |${2:group}| ${3} }
endsnippet

snippet eav "each_value" w
each_value { |${1:val}| ${2} }
endsnippet

snippet eawi "each_with_index" w
each_with_index { |${1:e}, ${2:i}| ${3} }
endsnippet

snippet reve "reverse_each" w
reverse_each { |${1:e}| ${2} }
endsnippet

snippet inj "inject" w
inject(${1:init}) { |${2:mem}, ${3:var}| ${4} }
endsnippet

snippet map "map" w
map { |${1:e}| ${2} }
endsnippet

snippet mapwi- "enum_with_index" w
enum_with_index.map { |${1:e}, ${2:i}| ${3} }
endsnippet

snippet sor "sort" w
sort { |a, b| ${1} }
endsnippet

snippet sorb "sort_by" w
sort_by { |${1:e}| ${2} }
endsnippet

snippet ran "sort_by rand" w
sort_by { rand }
endsnippet

snippet all "all?" w
all? { |${1:e}| ${2} }
endsnippet

snippet any "any?" w
any? { |${1:e}| ${2} }
endsnippet

snippet cl "classify" w
classify { |${1:e}| ${2} }
endsnippet

snippet col "collect" w
collect { |${1:e}| ${2} }
endsnippet

snippet det "detect" w
detect { |${1:e}| ${2} }
endsnippet

snippet fet "fetch" w
fetch(${1:name}) { |${2:key}| ${3} }
endsnippet

snippet fin "find" w
find { |${1:e}| ${2} }
endsnippet

snippet fina "find_all" w
find_all { |${1:e}| ${2} }
endsnippet

snippet gre "grep" w
grep(${1:/pattern/}) { |${2:match}| ${3} }
endsnippet

snippet sub
${1:g}sub(${2:/pattern/}) { |${3:match}| ${4} }
endsnippet

snippet sca "scan" w
scan(${1:/pattern/}) { |${2:match}| ${3} }
endsnippet

snippet max "max" w
max { |a, b| ${1} }
endsnippet

snippet min "min" w
min { |a, b| ${1} }
endsnippet

snippet par "partition" w
partition { |${1:e}| ${2} }
endsnippet

snippet rej "reject" w
reject { |${1:e}| ${2} }
endsnippet

snippet sel "select" w
select { |${1:e}| ${2} }
endsnippet

snippet lam "lambda" w
lambda { |${1:args}| ${2} }
endsnippet

snippet do
do |${1:variable}|
	${2}
end
endsnippet

snippet : "hash" w
${1:key}: ${2:'value'}${3}
endsnippet

snippet h "string hash" w
'${1:key}' => ${2:'value'}${3}
endsnippet

snippet ed "each block" w
${1:arr}.each do |${2:e}|
	${3}
end
endsnippet

# For rspec
snippet stubnew
allow(${1}).to receive(:new).with(${2}).and_return(${3})
endsnippet

snippet stub
allow(${1}).to receive(:${2}).and_return(${3})
endsnippet

snippet stubany
allow_any_instance_of(${1}).to receive(:${2}).and_return(${3})
endsnippet

snippet expect
expect(${1}).to have_received(:${2}).and_return(${3})
endsnippet

snippet expectany
expect_any_instance_of(${1}).to receive(:${2}).and_return(${3})
endsnippet

snippet desc
describe `!p
def ClassName(path):
	return re.sub(r'[_]', '', path.title())
snip.rv = ClassName(snip.basename)
` do
	subject(:instance) { described_class.new() }

	before do
	end

	describe '#$2' do
		subject(:${2}) { instance.$2 }

		it 'works' do
		end
	end
end
endsnippet

snippet descit
describe '#$1' do
	subject(:${1}) { instance.$1 }

	it 'works' do
		$1
	end
end
endsnippet

snippet descapi "describe api" w
describe '' do
	subject(:call) { call_api }

	it 'succeeds' do
		expect(call.status).to eq 200
	end
end
endsnippet

snippet let
let(:${1}) { ${2} }
endsnippet

snippet subject
subject(:${1}) { ${2} }
endsnippet

snippet it
it 'works' do
	${1}
end
endsnippet

snippet con
context '${1}' do
	${2}
end
endsnippet

snippet bed
before do
	${1}
end
endsnippet

snippet spec
require 'spec_helper'

describe ${1} do
	${2}
end
endsnippet

snippet rspec
require 'rails_helper'

describe ${1} do
  ${2}
end
endsnippet

snippet dc "described_class" w
described_class
endsnippet

snippet puts
puts "\n\n************ #{${1}} **************\n\n"
endsnippet

snippet px
puts "xxxxxxxxxxxxxx"
endsnippet

snippet ex
expect(${1}).to ${2}
endsnippet

snippet tz "timezone" w
Time.zone.now
endsnippet

snippet tc "Time.current" w
Time.current
endsnippet

snippet bod "Time.current.beginning_of_day" w
Time.current.beginning_of_day
endsnippet

snippet eod "Time.current.end_of_day" w
Time.current.end_of_day
endsnippet

snippet boh "Time.current.beginning_of_hour" w
Time.current.beginning_of_hour
endsnippet

snippet eoh "Time.current.end_of_hour" w
Time.current.end_of_hour
endsnippet

snippet ->
-> { ${0} }
endsnippet

snippet ->a
->(${1:args}) { ${0} }
endsnippet

snippet iexp
it { expect(${1:object}).${2} ${0} }
endsnippet

snippet iexpb
it { expect { ${1:object} }.${2} ${0} }
endsnippet

snippet exe
expect(${1:object}).to eq ${2:expectation}
endsnippet

snippet exp
expect(${1:object}).to be_present
endsnippet

snippet exs
expect(${1:object}.size).to eq ${0}
endsnippet

snippet ex2
expect(last_response.status).to eq 200
endsnippet

snippet fc "fixture create"
create(:${1:object})
endsnippet

snippet fcl "fixture create_list"
create_list(:${1:object}, ${2:number})
endsnippet

snippet gapi "Grape API Skeleton"
module V1
	class ${1:Model}API < Grape::API
		version 'v1', using: :header, vendor: '${1/./\l$0/}'
		format :json
		prefix :api

		helpers do
		end

		resource :${1/./\l$0/}s do
			get do
				@$1.limit(20)
			end

			params do
				requires :id, type: Integer, desc: '$1 id.'
			end
			route_param :id do
				get do
					@$1.find(params[:id])
				end
			end

			params do
			end
			post do
				@$1.create!({
				})
			end

			params do
				requires :id, type: String, desc: '$1 ID.'
			end
			put ':id' do
				@$1.find(params[:id]).update({
				})
			end

			params do
				requires :id, type: String, desc: '$1 ID.'
			end
			delete ':id' do
				@$1.find(params[:id]).destroy
			end
		end

	end
end
endsnippet

snippet docv "document_verification" w
document_verification
endsnippet

snippet doch "document_verification_history" w
document_verification_history
endsnippet

snippet Docv "DocumentVerification" w
DocumentVerification
endsnippet

snippet Doch "DocumentVerificationHistory" w
DocumentVerificationHistory
endsnippet

snippet tcat "text_category" w
text_category
endsnippet

snippet Tcat "TextCategory" w
TextCategory
endsnippet

snippet mod "moderator" w
moderator
endsnippet

snippet Mod "Moderator" w
Moderator
endsnippet

snippet cons "consensus" w
consensus
endsnippet

snippet Con "Consensus" w
Consensus
endsnippet

snippet conh "consensus_history" w
consensus_history
endsnippet

snippet Conh "ConsensusHistory" w
ConsensusHistory
endsnippet

snippet cb "call.body" w
call.body
endsnippet

snippet cs "call.status" w
call.status
endsnippet
