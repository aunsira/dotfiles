snippet bp "binding.pry"
require "pry"; binding.pry
endsnippet

# #!/usr/bin/ruby
snippet #! "#!/usr/bin/ruby"
#!/usr/bin/ruby
endsnippet

snippet req
require "${1}"${2}
endsnippet

snippet case
case ${1:object}
when ${2:condition}
${3}
endsnippet

snippet when
when ${1:condition}
	${2}
endsnippet

snippet def
def ${1}
	${2}
end
endsnippet

snippet defs
def self.$1
	$2
end
endsnippet

snippet defni
def ${1:name}${2:(${3:args})}
	fail(NotImplementedError.new)
end
endsnippet

snippet defi
def initialize(${1})
	${2}
end
endsnippet

snippet memo
def ${1}
	@$1 ||= ${2}
end
endsnippet

snippet deft
def test_${1:case_name}
	${2}
endsnippet

snippet def?
def ${1:name}?
	${2}
end
endsnippet

snippet ?
${1} ? ${2} : ${3}
endsnippet

snippet if
if ${1}
	${2}
end
endsnippet

snippet ife
if ${1}
	${2}
else
	${3}
end
endsnippet

snippet elsif
elsif ${1}
	${2}
endsnippet

snippet unless
unless ${1}
	${2}
end
endsnippet

snippet while
while ${1:condition}
	${2}
end
endsnippet

snippet until
until ${1:condition}
	${2}
end
endsnippet

snippet gd "guard clause"
return unless ${1}
endsnippet

snippet module "module .. end"
module `!p
def ClassName(path):
	return re.sub(r'[_]', '', path.title())
snip.rv = ClassName(snip.basename)
`
	${1}
end
endsnippet

snippet cla "class .. end"
class `!p
def ClassName(path):
	return re.sub(r'[_]', '', path.title())
snip.rv = ClassName(snip.basename)
`
	${1}
end
endsnippet

snippet cla "class .. initialize .. end"
class `!p
def ClassName(path):
	return re.sub(r'[_]', '', path.title())
snip.rv = ClassName(snip.basename)
`
	def initialize(${1:args})
		${3}
	end
end
endsnippet

snippet new "Class.new"
${1:Class}.new(${2:args})
endsnippet

# attr_reader
snippet r
attr_reader :${1}
endsnippet

# attr_writer
snippet w
attr_writer :${1}
endsnippet

# attr_accessor
snippet rw
attr_accessor :${1}
endsnippet

snippet tim "time" w
times { |${1:n}| ${2} }
endsnippet

snippet upt "upto" w
upto(${1:1.0/0.0}) { |${2:n}| ${3} }
endsnippet

snippet loo
loop { ${1} }
endsnippet

snippet ea "each" w
each { |${1:e}| ${2} }
endsnippet

snippet eab "each_byte" w
each_byte { |${1:byte}| ${2} }
endsnippet

snippet eac- "each_char { |chr| .. }" w
each_char { |${1:chr}| ${2} }
endsnippet

snippet eac- "each_cons(..) { |group| .. }" w
each_cons(${1:2}) { |${2:group}| ${3} }
endsnippet

snippet eai "each_index" w
each_index { |${1:i}| ${2} }
endsnippet

snippet eak "each_with_key" w
each_key { |${1:key}| ${2} }
endsnippet

snippet eal "each_line" w
each_line { |${1:line}| ${2} }
endsnippet

snippet eap "each_pair" w
each_pair { |${1:name}, ${2:val}| ${3} }
endsnippet

snippet eas- "each_slice" w
each_slice(${1:2}) { |${2:group}| ${3} }
endsnippet

snippet eav "each_value" w
each_value { |${1:val}| ${2} }
endsnippet

snippet eawi "each_with_index" w
each_with_index { |${1:e}, ${2:i}| ${3} }
endsnippet

snippet reve "reverse_each" w
reverse_each { |${1:e}| ${2} }
endsnippet

snippet inj "inject" w
inject(${1:init}) { |${2:mem}, ${3:var}| ${4} }
endsnippet

snippet map "map" w
map { |${1:e}| ${2} }
endsnippet

snippet mapwi- "enum_with_index" w
enum_with_index.map { |${1:e}, ${2:i}| ${3} }
endsnippet

snippet sor "sort" w
sort { |a, b| ${1} }
endsnippet

snippet sorb "sort_by" w
sort_by { |${1:e}| ${2} }
endsnippet

snippet ran "sort_by rand" w
sort_by { rand }
endsnippet

snippet all "all?" w
all? { |${1:e}| ${2} }
endsnippet

snippet any "any?" w
any? { |${1:e}| ${2} }
endsnippet

snippet cl "classify" w
classify { |${1:e}| ${2} }
endsnippet

snippet col "collect" w
collect { |${1:e}| ${2} }
endsnippet

snippet det "detect" w
detect { |${1:e}| ${2} }
endsnippet

snippet fet "fetch" w
fetch(${1:name}) { |${2:key}| ${3} }
endsnippet

snippet fin "find" w
find { |${1:e}| ${2} }
endsnippet

snippet fina "find_all" w
find_all { |${1:e}| ${2} }
endsnippet

snippet gre "grep" w
grep(${1:/pattern/}) { |${2:match}| ${3} }
endsnippet

snippet sub
subject { $1 }
endsnippet

snippet s "subject" w
subject
endsnippet

snippet sca "scan" w
scan(${1:/pattern/}) { |${2:match}| ${3} }
endsnippet

snippet max "max" w
max { |a, b| ${1} }
endsnippet

snippet min "min" w
min { |a, b| ${1} }
endsnippet

snippet par "partition" w
partition { |${1:e}| ${2} }
endsnippet

snippet rej "reject" w
reject { |${1:e}| ${2} }
endsnippet

snippet sel "select" w
select { |${1:e}| ${2} }
endsnippet

snippet lam "lambda" w
lambda { |${1:args}| ${2} }
endsnippet

snippet do
do |${1:variable}|
	${2}
end
endsnippet

snippet : "hash" w
${1:key}: ${2:'value'}${3}
endsnippet

snippet h "string hash" w
'${1:key}' => ${2:'value'}${3}
endsnippet

snippet ed "each block" w
${1:arr}.each do |${2:e}|
	${3}
end
endsnippet

# For rspec
snippet stubnew
allow(${1}).to receive(:new).with(${2}).and_return(${3})
endsnippet

snippet stub
allow(${1}).to receive(:${2}).and_return(${3})
endsnippet

snippet stubany
allow_any_instance_of(${1}).to receive(:${2}).and_return(${3})
endsnippet

snippet expect
expect(${1}).to have_received(:${2}).and_return(${3})
endsnippet

snippet expectany
expect_any_instance_of(${1}).to receive(:${2}).and_return(${3})
endsnippet

snippet de
describe '${1}' do
	${2}
end
endsnippet

snippet desc
describe `!p
def ClassName(path):
	return re.sub(r'[_]', '', path.title())
snip.rv = ClassName(snip.basename)
` do
	subject(:instance) { described_class.new() }

	before do
	end

	describe '#$2' do
		subject(:${2}) { instance.$2 }

		it 'works' do
		end
	end
end
endsnippet

snippet descit
describe '$1' do
	subject { instance.${1} }

	it 'works' do
		subject
	end
end
endsnippet

snippet descapi "describe api" w
describe '' do
	subject { call_api }

	it 'succeeds' do
		expect(subject.status).to eq 200
	end
end
endsnippet

snippet deindex "describe index action" w
let(:user) { create(:user) }
let(:format) { :html }

before do
	sign_in user
end

describe 'GET #index' do
	subject { get :index, params: params, format: format }

	let(:params) { {  } }

	context 'succeeds' do
		it 'returns 200' do
			expect(subject).to have_http_status(:ok)
		end

		it 'assigns ${1:resource}' do
			subject
			expect(assigns(:$1)).to eq 'foo'
		end
	end
end
endsnippet

snippet deshow "describe show action" w
let(:user) { create(:user) }
let(:format) { :html }

before do
	sign_in user
end

describe 'GET #show' do
	subject { get :show, params: params, format: format }

	let(:params) { {  } }

	context 'succeeds' do
		it 'returns 200' do
			expect(subject).to have_http_status(:ok)
		end

		it 'assigns ${1:resource}' do
			subject
			expect(assigns(:$1)).to eq 'foo'
		end
	end
end
endsnippet

snippet deupdate "describe update action" w
describe 'PUT #update' do
	subject { put :update, params: params, format: format }

	let(:params) { {  } }

	context 'succeeds' do
		it { is_expected.to redirect_to(root_url) }

		it 'updates ${1:resource} ${2:attribute}' do
			expect { subject }.to change { $1.reload.$2 }.to('foo')
		end
	end
end
endsnippet

snippet decreate "describe create action" w
describe 'POST #create' do
	subject { post :create, params: params, format: format }

	let(:params) { {  } }

	context 'succeeds' do
		it { is_expected.to redirect_to(root_url) }

		it 'creates ${1:resource} ${2:attribute}' do
			expect { subject }.to change($1, :count).by(1)
		end
	end
end
endsnippet

snippet let
let(:${1}) { ${2} }
endsnippet

snippet subject
subject(:${1}) { ${2} }
endsnippet

snippet it
it '${1}' do
	${2}
end
endsnippet

snippet con
context '${1}' do
	${2}
end
endsnippet

snippet bed
before do
	${1}
end
endsnippet

snippet spec
require 'rails_helper'

describe ${1} do
	${2}
end
endsnippet

snippet rspec
require 'rails_helper'

describe ${1} do
	describe '${2:docstring}' do
		it 'works' do
			${3}
		end
	end
end
endsnippet

snippet dc "described_class" w
described_class
endsnippet

snippet puts
puts "\n\n************ #{ ${1} } **************\n\n"
endsnippet

snippet px
puts "xxxxxxxxxxxxxx"
endsnippet

snippet ex
expect(subject).to ${0}
endsnippet

snippet tz "timezone" w
Time.zone.now
endsnippet

snippet tc "Time.current" w
Time.current
endsnippet

snippet bod "Time.current.beginning_of_day" w
Time.current.beginning_of_day
endsnippet

snippet eod "Time.current.end_of_day" w
Time.current.end_of_day
endsnippet

snippet boh "Time.current.beginning_of_hour" w
Time.current.beginning_of_hour
endsnippet

snippet eoh "Time.current.end_of_hour" w
Time.current.end_of_hour
endsnippet

snippet ->
-> { ${0} }
endsnippet

snippet ->a
->(${1:args}) { ${0} }
endsnippet

snippet iexp
it { expect(subject).${1} ${2} }
endsnippet

snippet iexpb
it { expect { subject }.${1} ${2} }
endsnippet

snippet isexp
it { is_expected.to eq ${0} }
endsnippet

snippet exe
expect(subject).to eq ${1}
endsnippet

snippet exp
expect(subject).to be_present
endsnippet

snippet exs
expect(subject.size).to eq ${0}
endsnippet

snippet exs2
expect(subject.status).to eq 200
endsnippet

snippet fc "fixture create"
create(:${1})
endsnippet

snippet fcl "fixture create_list"
create_list(:${1:object}, ${2:number})
endsnippet

snippet bs "fixture build_stubbed"
build_stubbed(:${1})
endsnippet

snippet gapi "Grape API Skeleton"
module V1
	class ${1:Model}API < Grape::API
		version 'v1', using: :header, vendor: '${1/./\l$0/}'
		format :json
		prefix :api

		helpers do
		end

		resource :${1/./\l$0/}s do
			get do
				@$1.limit(20)
			end

			params do
				requires :id, type: Integer, desc: '$1 id.'
			end
			route_param :id do
				get do
					@$1.find(params[:id])
				end
			end

			params do
			end
			post do
				@$1.create!({
				})
			end

			params do
				requires :id, type: String, desc: '$1 ID.'
			end
			put ':id' do
				@$1.find(params[:id]).update({
				})
			end

			params do
				requires :id, type: String, desc: '$1 ID.'
			end
			delete ':id' do
				@$1.find(params[:id]).destroy
			end
		end

	end
end
endsnippet

snippet docv "document_verification" w
document_verification
endsnippet

snippet doch "document_verification_history" w
document_verification_history
endsnippet

snippet Docv "DocumentVerification" w
DocumentVerification
endsnippet

snippet Doch "DocumentVerificationHistory" w
DocumentVerificationHistory
endsnippet

snippet mod "moderator" w
moderation
endsnippet

snippet Mod "Moderator" w
Moderation
endsnippet

snippet cons "consensus" w
consensus
endsnippet

snippet Con "Consensus" w
Consensus
endsnippet

snippet db "database" w
database
endsnippet

snippet DB "Database" w
Database
endsnippet

snippet conh "consensus_history" w
consensus_history
endsnippet

snippet Conh "ConsensusHistory" w
ConsensusHistory
endsnippet

snippet sb "subject.body" w
subject.body
endsnippet

snippet ss "subject.status" w
subject.status
endsnippet

snippet tx "transaction" w
transaction
endsnippet

snippet Tx "Transaction" w
Transaction
endsnippet


snippet ba
before_action :${0:method}
endsnippet

snippet bt
belongs_to :${0:association}
endsnippet

snippet btp
belongs_to :${1:association}, polymorphic: true
endsnippet

snippet crw
cattr_accessor :${0:attr_names}
endsnippet

snippet clac "Create controller class"
class ${1:Model}Controller < ApplicationController
	before_action :find_${2:model}

	$0

	private
	def find_$2
		@$2 = ${3:$1}.find(params[:id]) if params[:id]
	end
end
endsnippet

snippet resources "Create resources controller class"
class ${0:$1}sController < ApplicationController
	before_action :find_${1/./\l$0/}, only: %i[show edit update destroy]

	# GET /${1/./\l$0/}s
	def index
		@${1/./\l$0/}s = ${1:$1}.all

		respond_to do |format|
			format.html
			format.json { render json: @${1/./\l$0/}s }
		end
	end

	# GET /${1/./\l$0/}s/1
	def show
		respond_to do |format|
			format.html
			format.json { render json: @${1/./\l$0/} }
		end
	end

	# GET /${1/./\l$0/}s/new
	def new
		@${1/./\l$0/} = ${1:$1}.new

		respond_to do |format|
			format.html
			format.json { render json: @${1/./\l$0/} }
		end
	end

	# GET /${1/./\l$0/}s/1/edit
	def edit
	end

	# POST /${1/./\l$0/}s
	def create
		@${1/./\l$0/} = ${1:$1}.new(params[:${1/./\l$0/}])

		respond_to do |format|
			if @${1/./\l$0/}.save
				format.html { redirect_to(@${1/./\l$0/}), notice: '${1:$1} was successfully created.' }
				format.json { render json: @${1/./\l$0/}, status: :created }
			else
				format.html { render :new, status: :unprocessable_entity }
				format.json { render json: @${1/./\l$0/}.errors, status: :unprocessable_entity }
			end
		end
	end

	# PUT /${1/./\l$0/}s/1
	def update
		respond_to do |format|
			if @${1/./\l$0/}.update(params[:${1/./\l$0/}])
				format.html { redirect_to(@${1/./\l$0/}), notice: '${1:$1} was successfully updated.' }
				format.json { render json: @${1/./\l$0/} }
			else
				format.html { render :edit, status: :unprocessable_entity }
				format.json { render json: @${1/./\l$0/}.errors, status: :unprocessable_entity }
			end
		end
	end

	# DELETE /${1/./\l$0/}s/1
	def destroy
		@${1/./\l$0/}.destroy

		respond_to do |format|
			format.html { redirect_to(${1/./\l$0/}s_url) }
			format.json { render json: :success }
		end
	end

	private

	def find_${1/./\l$0/}
		@${1/./\l$0/} = ${1:Model}.find(params[:id])
	end

end
endsnippet

snippet defcreate
def create
	@${1:model_class_name} = ${2:ModelClassName}.new($1_params)

	respond_to do |format|
		if @$1.save
			format.html { redirect_to($1s_url), notice: '$2 was successfully created.' }
			format.json do
				render json: @$1,
							 serializer: $3,
							 adapter: :json,
							 status: :created
			end
		else
			format.html { render :new, status: :unprocessable_entity }
			format.json { render json: @$1.errors, status: :unprocessable_entity }
		end
	end
end
endsnippet

snippet defdestroy
def destroy
	@${1:model_class_name} = ${2:ModelClassName}.find(params[:id])
	@$1.destroy

	respond_to do |format|
		format.html { redirect_to($1s_url) }
		format.json { render json: :success }
	end
end
endsnippet

snippet defedit
def edit
	@${1:model_class_name} = ${0:ModelClassName}.find(params[:id])
end
endsnippet

snippet defindex
def index
	@${1:model_class_name} = ${2:ModelClassName}.all

	respond_to do |format|
		format.html
		format.json do
			render json: @$1,
						 each_serializer: $3,
						 meta: pagination_meta(@$1, per, page),
						 adapter: :json
		end
	end
end
endsnippet

snippet defnew
def new
	@${1:model_class_name} = ${2:ModelClassName}.new

	respond_to do |format|
		format.html
		format.json { render json: @$1 }
	end
end
endsnippet

snippet defshow
def show
	@${1:model_class_name} = ${2:ModelClassName}.find(params[:id])

	respond_to do |format|
		format.html
		format.json { render json: @$1 }
	end
end
endsnippet

snippet defupdate
def update
	@${1:model_class_name} = ${2:ModelClassName}.find(params[:id])

	respond_to do |format|
		if @$1.update($1_params)
			format.html { redirect_to($1s_url), notice: '$2 was successfully updated.' }
			format.json do
				render json: @$1,
							 serializer: $3,
							 adapter: :json
			end
		else
			format.html { render :edit, status: :unprocessable_entity }
			format.json { render json: @$1.errors, status: :unprocessable_entity }
		end
	end
end
endsnippet

snippet defparams
def ${1:model_class_name}_params
	params.require(:$1).permit()
end
endsnippet

snippet pag "page" w
page($1).per($2)
endsnippet

snippet act_serial
class `!p
def ClassName(path):
	return re.sub(r'[_]', '', path.title())
snip.rv = ClassName(snip.basename)
` < ActiveModel::Serializer
	attributes :$1
end
endsnippet

snippet fast_serial
class `!p
def ClassName(path):
	return re.sub(r'[_]', '', path.title())
snip.rv = ClassName(snip.basename)
`
	include FastJsonapi::ObjectSerializer

	attributes :$1
end
endsnippet

snippet dele
delegate :${1:methods}, to: :${0:object}
endsnippet

snippet dele
delegate :${1:methods}, to: :${2:object}, prefix: :${3:prefix}, allow_nil: ${0:allow_nil}
endsnippet

snippet amc
alias_method_chain :${1:method_name}, :${0:feature}
endsnippet

snippet flash
flash[:${1:notice}] = '${0}'
endsnippet

snippet habtm
has_and_belongs_to_many :${1:object}, join_table: '${2:table_name}', foreign_key: '${3}_id'
endsnippet

snippet hm
has_many :${0:object}
endsnippet

snippet hmd
has_many :${1:other}s, class_name: '${2:$1}', foreign_key: '${3:$1}_id', dependent: :destroy
endsnippet

snippet hmt
has_many :${1:object}, through: :${0:object}
endsnippet

snippet ho
has_one :${0:object}
endsnippet

snippet hod
has_one :${1:object}, dependent: :${0:destroy}
endsnippet

snippet i18
I18n.t('${1:type.key}')
endsnippet

snippet ist
<%= image_submit_tag('${1:agree.png}', id: '${2:id}'${0}) %>
endsnippet

snippet log
Rails.logger.${1:debug} ${0}
endsnippet

snippet log2
RAILS_DEFAULT_LOGGER.${1:debug} ${0}
endsnippet

snippet logd
Rails.logger.debug '${1:message}'
endsnippet

snippet loge
Rails.logger.error '${1:message}'
endsnippet

snippet logf
Rails.logger.fatal '${1:message}'
endsnippet

snippet logi
Rails.logger.info '${1:message}'
endsnippet

snippet logw
Rails.logger.warn '${1:message}'
endsnippet

snippet mapc
${1:map}.${2:connect} '${0:controller/:action/:id}'
endsnippet

snippet mapca
${1:map}.catch_all '*${2:anything}', controller: '${3:default}', action: '${4:error}'
endsnippet

snippet mapr
${1:map}.resource :${0:resource}
endsnippet

snippet maprs
${1:map}.resources :${0:resource}
endsnippet

snippet mapwo
${1:map}.with_options ${2:controller}: '${3:thing}' do |$3|
	${0}
end
endsnippet

# Model validation
snippet vn
validates :${0:attribute}, numericality: true
endsnippet

snippet vp
validates :${0:attribute}, presence: true
endsnippet

snippet vu
validates :${0:attribute}, uniqueness: true
endsnippet

###############################
#   model callback snippets   #
###############################

# before callback
snippet mbv
before_validation :${0:method}
endsnippet

snippet mbc
before_create :${0:method}
endsnippet

snippet mbu
before_update :${0:method}
endsnippet

snippet mbs
before_save :${0:method}
endsnippet

snippet mbd
before_destroy :${0:method}
endsnippet

snippet mp "map attribute" w
map(&:${0:id})
endsnippet

snippet mrw
mattr_accessor :${0:attr_names}
endsnippet

snippet oa "order" w
order('${0:field}')
endsnippet

snippet od "order desc" w
order('${0:field} DESC')
endsnippet

snippet pa "params" w
params[:${1:id}]
endsnippet

snippet op "options" w
options[:${1:id}]
endsnippet

snippet ra
render action: '${0:action}'
endsnippet

snippet ral
render action: '${1:action}', layout: '${0:layoutname}'
endsnippet

snippet re
redirect_to action: :${0:action}
endsnippet

snippet sc
scope :${1:name}, -> { where(${2:field}: ${0:value}) }
endsnippet

snippet sl
scope :${1:name}, lambda do |${2:value}|
	where('${3:field = ?}', ${0:value})
end
endsnippet

###########################
#   migrations snippets   #
###########################
snippet mac
add_column :${1:table_name}, :${2:column_name}, :${0:data_type}
endsnippet

snippet mai
add_index :${1:table_name}, :${0:column_name}
endsnippet

snippet mrc
remove_column :${1:table_name}, :${0:column_name}
endsnippet

snippet mrnc
rename_column :${1:table_name}, :${2:old_column_name}, :${0:new_column_name}
endsnippet

snippet mcc
change_column :${1:table}, :${2:column}, :${0:type}
endsnippet

snippet mnc
t.${1:string} :${2:title}${3:, null: false}
endsnippet

snippet mct
create_table :${1:table_name} do |t|
	${0}
end
endsnippet

snippet migration
class `substitute( substitute(vim_snippets#Filename(), '^\d\+_', '',''), '\(_\|^\)\(.\)', '\u\2', 'g')` < ActiveRecord::Migration
	def up
		${0}
	end

	def down
	end
end
endsnippet

snippet migration
class `substitute( substitute(vim_snippets#Filename(), '^\d\+_', '',''), '\(_\|^\)\(.\)', '\u\2', 'g')` < ActiveRecord::Migration
	def change
		${0}
	end
end
endsnippet

snippet trc
t.remove :${0:column}
endsnippet

snippet tre
t.rename :${1:old_column_name}, :${2:new_column_name}
${0}
endsnippet

snippet tref
t.references :${0:model}
endsnippet

snippet tcb
t.boolean :${1:title}
${0}
endsnippet

snippet tcbi
t.binary :${1:title}, limit: ${2:2}.megabytes
${0}
endsnippet

snippet tcd
t.decimal :${1:title}, precision: ${2:10}, scale: ${3:2}
${0}
endsnippet

snippet tcda
t.date :${1:title}
${0}
endsnippet

snippet tcdt
t.datetime :${1:title}
${0}
endsnippet

snippet tcf
t.float :${1:title}
${0}
endsnippet

snippet tch
t.change :${1:name}, :${2:string}, ${3:limit}: ${4:80}
${0}
endsnippet

snippet tci
t.integer :${1:title}
${0}
endsnippet

snippet tcl
t.integer :lock_version, null: false, default: 0
${0}
endsnippet

snippet tcr
t.references :${1:taggable}, polymorphic: { default: '${2:Photo}' }
${0}
endsnippet

snippet tcs
t.string :${1:title}
${0}
endsnippet

snippet tct
t.text :${1:title}
${0}
endsnippet

snippet tcti
t.time :${1:title}
${0}
endsnippet

snippet tcts
t.timestamp :${1:title}
${0}
endsnippet

snippet tctss
t.timestamps
${0}
endsnippet

snippet whe
${1:Model}.where(${2:attr}: ${3:value})
endsnippet

snippet fi
${1:Model}.find_by(${2:attr}: ${3:value})
endsnippet

snippet rh
require 'rails_helper'

describe ${1:ClassName} do
	describe '${2:docstring}' do
		it '$3' do
			$4
		end
	end
end
endsnippet

snippet dis:multi
# rubocop:disable RSpec/MultipleExpectations
endsnippet

snippet dis:any
# rubocop:disable RSpec/AnyInstance
endsnippet

snippet dis:line
# rubocop:disable Layout/LineLength
endsnippet

snippet dis:all
# rubocop:disable all
endsnippet

snippet dis:nested
# rubocop:disable RSpec/NestedGroups
endsnippet
